\documentclass{report}

%* Packages Used

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage{verbatim}
\usepackage{fancyvrb}

\usepackage{listings}
\usepackage{xcolor}


\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{float}


%* Package settings
\hypersetup{
colorlinks  = true,
linkcolor   = black,
urlcolor    = red,
}

\newgeometry{
      top = 0.75in,
      bottom = 0.75in,
      left = 0.75in,
      right = 0.75in,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
\lstset{language=Python}

%* Preamble
\title{
\includegraphics[width=0.5\textwidth]{resources/ua_logo.png} \\
Industrial Robotics TP2\\
\Large{University of Aveiro}
}

\author{Bruno Silva 98374\\
\href{https://github.com/brunofavs/TP2_RI}{Github Repository}
}

\setcounter{chapter}{1}

\begin{document}

\maketitle

\tableofcontents
\pagebreak


\section{Introduction}

This program was developed with the purpose of studying and consolidating
knowledge about robotic kinematics, including direct, inverse and differential
kinematics, three foundational pillars of any robotic system.

The general goal was to create an 9 degree of freedom(DOF) robot similar to a
construction crane, made of both rotational and prismatic joints, capable of
following a pre-determined path. The conceptual goal was to simulate the robot
that would be in a hypothetical real life scenario assembling big Christmas trees.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{resources/system_home.jpg}
    \caption{\label{fig:home}Robot and Path to follow.}
\end{figure}


\section{Script Analysis}

This section is aimed at briefly explaining the steps the script takes in order
to accomplish the desired objective as stated in the previous section.

\subsection{Tree Initialization}

The tree models were modeled in \textit{SolidWorks} and exported as
\textit{STL's}. Afterwards, a script found ind
\href{https://www.mathworks.com/matlabcentral/fileexchange/22409-stl-file-reader?s_tid=srchtitle}{\textit{Matlab's
        File Exchange}} was used to import the \textit{STL's} into \textit{Matlab} as
patch objects. Being patch objects, any geometric transformation can be applied
to them. This was done to position the tree at the correct position and modify
the offset from the robot.

\subsection{Computing path and $\psi$}

If the tree had been drawn by computing the equations "by hand", this step
would've been easier. The procedure was the following:\begin{enumerate}
    \item Find the tip of the tree by visually inspecting the patch object drawn;
    \item Compute the end points of each segment based on the tree radius and height;
    \item Do linear interpolation for the linear segments
    \item Use the
          \href{https://www.mathworks.com/matlabcentral/fileexchange/123050-3d-arc-passing-through-3-points?s_tid=srchtitle}{\textbf{arc3}}
          to compute the point along the circular segments.\footnote{Unlike the first
              project, here the third point required by the script was quite easy to
              compute considering all circular segments are half full circles and were
              always on the \textit{Oxy} plane}
\end{enumerate}

To compute the angle of the tool end point (TCP) of the crane, a simple dot
product of the vectors made by the points represented in the \hyperref[fig:psi]{figure}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.1]{resources/psi.jpeg}
    \caption{\label{fig:psi}$\psi$ computing based on a cross-section of the
        tree}
    \footnote{The yellow square represents the operator's cabin}
\end{figure}

The \hyperref[fig:psi]{figure} represents a cross-section of the tree for a given radius.
Based on $P_c$,$P_0$,$P_i$, the angle $\psi$ is computed for each
point. Afterwards, to determine the angle signal, the cross-product of the same
vectors is computed.

\subsection{Robot Initialization}

The robot dimensions are loaded from a text file that should be present in the
main script's path and named \textit{"tp2.txt"}. The joint lengths should be in
the format $La = int$. A status message should be displayed to verify if the
parameters established by the user are correctly loaded.

In order to establish the \textit{\textbf{Denavit-Hartenberg}} parameters, a
schematic of the robot was made using a diagram drawing
software, \textit{LucidChart}. The reference frames and the resulting \hyperref[tab:dh]{\textbf{DH table}}
can be seen below:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{resources/robot_draw.jpeg}
    \caption{\label{fig:r_draw}Robot schematic and reference frames}
\end{figure}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Joint & $\theta_i$                 & $l_i$ & $d_i$                  & $\alpha_i$       \\
        \hline
        1     & $\theta_1$                 & 0     & $La$                   & $-\frac{\pi}{2}$ \\
        \hline
        2     & $-\theta_2$                & $Lb$  & 0                      & 0                \\
        \hline
        3     & $\theta_3 - \frac{\pi}{2}$ & $Lc$  & 0                      & 0                \\
        \hline
        4     & $\theta_4 - \frac{\pi}{2}$ & $Ld$  & 0                      & 0                \\
        \hline
        5     & $\theta_5 + \frac{\pi}{2}$ & $Le$  & 0                      & 0                \\
        \hline
        6     & $\theta_6$                 & 0     & 0                      & $-\frac{\pi}{2}$ \\
        \hline
        7     & 0                          & 0     & $Lf_{\text{min}} + d7$ & $\frac{\pi}{2}$  \\
        \hline
        8     & $\frac{\pi}{2} + \theta_8$ & $Lg$  & 0                      & $\frac{\pi}{2}$  \\
        \hline
        9     & $\theta_9$                 & $Lh$  & 0                      & 0                \\
        \hline
    \end{tabular}
    \caption{DH table}
    \label{tab:dh}
\end{table}


To draw the joints, the same procedure used to load the trees was used. To align
them and move them with the robot reference frames, in the \textit{animateRobot}
function, the cumulative AA transformation was computed and was applied to each
body corresponding to the joint it was representing.

\subsection{Inverse Kinematics}

To compute the inverse kinematics(IK) the approach was the following: \begin{enumerate}
    \item Compute the IK of the joints 6 to 9;
    \item Compute the $\theta_1$ and update $\theta_9$ based on the $\psi$ angle;
    \item Compute the IK of the joints 2 to 6;
    \item Stitch the segments together.
\end{enumerate}

Matlab's symbolic calculus capabilities were heavily used to solve the equations
showed ahead.

The first segment, from joint 1 to 9, assumed that:\begin{itemize}
    \item $\theta_8 = -\theta_6$
\end{itemize}

With this simplification, the position elements of the AAA matrix from joint 6
to 9 yields the following system of equations :

\begin{equation}
    \begin{cases}
        x_{69} = -\sin(\theta_6)(Lf_{\text{min}} + d7)                                    \\
        y_{69} = Lg + Lf_{\text{min}}\cos(\theta_6) + Lh\cos(\theta_9) + d7\cos(\theta_6) \\
        z_{69} = Lh\sin(\theta_9)
    \end{cases}
\end{equation}

Solving this system using Matlab's built-in solver gave the following results :

\begin{equation}
    \begin{cases}
        q_9 = arcsin(\frac{z_{69}}{L_h}) \\
        k = L_g + L_h*cos(q_9)-y_{69}    \\
        q_6 = artan(\frac{x_{69}}{k})    \\
        d_7 = \frac{sin(arctan(\frac{x_{69}}{k}))}{-L_{fMin}*sin(arctan(\frac{x}{k}))+x_{69}}
    \end{cases}
\end{equation}

With this, the robot could go to the desired points, however 2 things were still wrong:\begin{itemize}
    \item No orientation relative to the tree
    \item The prismatic joint limit was being surpassed
\end{itemize}

This can be seen in the \hyperref[fig:69]{figure below}\footnote{This is a old
    commit of the project, a lot of features were still missing and the path for
    example was being wrongly displayed}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{resources/69_no_orientation.jpg}
    \caption{\label{fig:69} KI just with joints 6 to 9 unlocked}
\end{figure}

After, the next step was to unlock the base joint, to allow for redundancy and
establish the desired orientation. The \hyperref[fig:theta_9]{figure} below
shows a top view of the robot's joints for a given $\theta_6$ and $d_7$. From
the figure using sin's law the equation for $theta_1$ and $\theta_9$ can be
deduced. Here, the initial values for $\theta_6$ and $d_7$ were arbitrated to be
the output from the previously computed \textit{KI} from joint 6 to 9.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{resources/theta_9.jpeg}
    \caption{\label{fig:theta_9} Top view of the robot with orientation to the tree} 
\end{figure}

Using the terminology from the figure \ref{fig:theta_9}, a few things are worth highlighting:\begin{itemize}
    \item $L_{fixed}$ is always the same known lengths;
    \item $L_{angled}$ and $L_i$ change according to the values of the joints 6
    and 7;
    \item The following equations are valid only for the case where the joint 1
    and 6 are vertically aligned. This will be further explained after.
\end{itemize}

Directly from sin's law comes :

\begin{equation}
    \frac{sin(\psi)}{L_{angled}}=\frac{sin(\theta_1)}{L_{fixed}} =\frac{sin(\pi-\theta_9)}{L_i}
\end{equation}

From here, $L_{angled}$ is still unknown, as the segment is longer and requires
a new value of either $\theta_6$ or $d_7$. $L_{angled}$ was determined using the
cosine's law :

\begin{equation}
L_{angled} = \sqrt{L_{fixed}^2 + L_i^2 - 2 \cdot L_{fixed} \cdot L_i \cdot \cos(\psi)}
\end{equation}

And the updated $d_7$ was computed like so:

\begin{equation}
    d_7 = \frac{{L_{angled} - L_{f_{min}} \cdot \cos(\left| \theta_6 \right|) - L_g}}{{\cos(\left| \theta_6 \right|)}}
\end{equation}

Solving these equations in order to $\theta_1$ and $\theta_9$ yields the new values,
aligning the robot with the tree.






\subsection{Differential Kinematics}

\subsection{Prismatic Joint Limit Analysis}




\section{Additional notes}

\begin{itemize}

    \item Video links \begin{itemize}
              \item \href{}{Demo Video}
          \end{itemize}

    \item \href{https://github.com/brunofavs/TP2_RI}{Github Repository link}

\end{itemize}














\end{document}